<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f1a" />
  <title>Futuristic TM Vision — Mobile</title>
  <style>
    :root{
      --bg:#070b12;        /* deep space */
      --fg:#d6f3ff;        /* pale cyan */
      --neon:#18e0ff;      /* main neon */
      --neon2:#7cffd9;     /* accent neon */
      --danger:#ff4477;    /* alert */
      --scan:rgba(24,224,255,.12);
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html,body{height:100%;}
    body{
      margin:0; background:radial-gradient(1200px 800px at 50% -10%,#0f1630 0%,var(--bg) 40%, #05070c 100%);
      color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      overflow:hidden;
    }

    /* Fullscreen stage */
    .stage{
      position:fixed; inset:0; width:100vw; height:100vh;
      display:grid; place-items:center;
    }

    /* Webcam canvas fills screen (portrait-first). */
    #webcam-wrap{position:relative; width:100vw; height:100vh;}
    #webcam-wrap canvas{position:absolute; inset:0; width:100%; height:100%; object-fit:cover;}

    /* Hologram overlay */
    .overlay{
      position:absolute; inset:0; pointer-events:none; overflow:hidden;
      filter: drop-shadow(0 0 10px rgba(24,224,255,.3));
    }
    /* subtle grid */
    .overlay::before{
      content:""; position:absolute; inset:-2px;
      background:
        linear-gradient(transparent 95%, rgba(124,255,217,.25) 96%, transparent 97%),
        repeating-linear-gradient(0deg, rgba(124,255,217,.06) 0 1px, transparent 1px 40px),
        repeating-linear-gradient(90deg, rgba(24,224,255,.05) 0 1px, transparent 1px 40px);
      mix-blend-mode:screen; opacity:.6;
      animation: gridshift 18s linear infinite;
    }
    @keyframes gridshift{from{transform:translateY(0)} to{transform:translateY(-40px)}}

    /* scanning line */
    .scanline{position:absolute; left:2%; right:2%; height:16vh; top:-20%;
      border:1px solid rgba(24,224,255,.35);
      box-shadow:0 0 24px rgba(24,224,255,.2) inset, 0 0 32px rgba(24,224,255,.15);
      background: linear-gradient(to bottom, rgba(24,224,255,.0), rgba(24,224,255,.18), rgba(24,224,255,.0));
      filter: blur(.3px);
      animation: sweep 3.2s linear infinite;
    }
    @keyframes sweep{from{top:-25%} to{top:110%}}

    /* corner brackets */
    .br{position:absolute; width:26vw; height:18vh; border:2px solid var(--neon); opacity:.6; filter:drop-shadow(0 0 6px var(--neon));}
    .br.tl{top:3%; left:3%; border-right:none; border-bottom:none; border-radius:16px 0 0 0;}
    .br.tr{top:3%; right:3%; border-left:none; border-bottom:none; border-radius:0 16px 0 0;}
    .br.bl{bottom:3%; left:3%; border-right:none; border-top:none; border-radius:0 0 0 16px;}
    .br.br{bottom:3%; right:3%; border-left:none; border-top:none; border-radius:0 0 16px 0;}

    /* target reticle */
    .reticle{position:absolute; inset:0; display:grid; place-items:center;}
    .reticle::before{
      content:""; width:28vmin; height:28vmin; border:1px dashed rgba(24,224,255,.45);
      border-radius:50%; box-shadow:0 0 20px rgba(24,224,255,.2) inset;
      animation: pulse 1.8s ease-in-out infinite;
    }
    @keyframes pulse{0%,100%{transform:scale(.98)}50%{transform:scale(1.02)}}

    /* HUD container */
    .hud{position:absolute; top:env(safe-area-inset-top, 12px); left:0; right:0; display:flex; justify-content:space-between; align-items:center; padding: 12px 16px;}
    .pill{background:rgba(7,11,18,.55); border:1px solid rgba(124,255,217,.25); backdrop-filter: blur(8px);
      padding:8px 12px; border-radius:999px; font-size:14px; letter-spacing:.08em; text-transform:uppercase;
      text-shadow:0 0 8px rgba(24,224,255,.35);
    }

    /* Futuristic number (1–5) */
    .number{
      position:absolute; left:50%; bottom:8vh; transform:translateX(-50%);
      font-size:18vmin; line-height:1; font-weight:800; letter-spacing:.06em;
      color:var(--fg);
      text-shadow:0 0 20px rgba(24,224,255,.65), 0 0 60px rgba(124,255,217,.35);
      opacity:0; transform-origin:center; filter: drop-shadow(0 0 6px var(--neon));
    }
    .number.active{opacity:1; animation: popin 600ms cubic-bezier(.22,1.56,.24,1) both, hover 3s ease-in-out 600ms infinite;}
    @keyframes popin{0%{transform:translateX(-50%) translateY(20px) scale(.1) rotateX(80deg); filter:blur(6px);}60%{filter:blur(0)}100%{transform:translateX(-50%) translateY(0) scale(1) rotateX(0deg)}}
    @keyframes hover{0%,100%{transform:translateX(-50%) translateY(0) scale(1)}50%{transform:translateX(-50%) translateY(-6px) scale(1.02)}}

    /* detection state intensifies overlay */
    .overlay.active::before{opacity:.9}
    .overlay.active .scanline{animation-duration:2.2s}
    .overlay.active .reticle::before{border-color:var(--neon2); box-shadow:0 0 24px rgba(124,255,217,.35) inset}

    /* Floating tips */
    .tip{position:absolute; right:12px; bottom: env(safe-area-inset-bottom, 16px); opacity:.8; font-size:12px}

    /* Start screen */
    .gate{
      position:fixed; inset:0; display:grid; place-items:center; gap:18px; background: radial-gradient(800px 500px at 50% 20%, rgba(24,224,255,.08), rgba(7,11,18,.9)); z-index:10;
    }
    .brand{display:flex; flex-direction:column; align-items:center; gap:8px}
    .brand h1{margin:0; font-size:22px; letter-spacing:.12em; font-weight:700; text-transform:uppercase}
    .brand small{opacity:.7; letter-spacing:.12em}
    .btn{
      border:none; padding:14px 22px; border-radius:14px; font-weight:700; letter-spacing:.08em; text-transform:uppercase; cursor:pointer;
      background:linear-gradient(135deg, #0ecbff 0%, #54ffd5 100%);
      color:#001018; box-shadow:0 8px 30px rgba(24,224,255,.35), inset 0 0 10px rgba(255,255,255,.25);
    }

    /* Hide on landscape tablets: still mobile-first but responsive */
    @media (orientation:landscape) and (max-height:480px){
      .tip{display:none}
    }
  </style>
</head>
<body>

  <!-- Launch gate (required for mobile camera autoplay) -->
  <div class="gate" id="gate">
    <div class="brand">
      <h1>Teachable Machine Vision</h1>
      <small>Futuristic Mobile Scanner</small>
    </div>
    <button class="btn" id="startBtn">Start</button>
  </div>

  <div class="stage">
    <div id="webcam-wrap">
      <!-- tmImage will inject <canvas> here -->
      <div class="overlay" id="overlay">
        <div class="scanline"></div>
        <div class="br tl"></div>
        <div class="br tr"></div>
        <div class="br bl"></div>
        <div class="br br"></div>
        <div class="reticle"></div>
        <div class="hud">
          <div class="pill" id="hudLabel">Menunggu kamera…</div>
          <div class="pill" id="hudConf">0%</div>
        </div>
        <div class="number" id="futuristicNumber">0</div>
        <div class="tip">> Arahkan kamera ke objek • ambang 50%</div>
      </div>
    </div>
  </div>

  <!-- TFJS + Teachable Machine -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
  <script>
    const URL = "https://teachablemachine.withgoogle.com/models/lwqdu_RK8/"; // user model

    let model, webcam, labelContainer, maxPredictions;
    const wrap = document.getElementById('webcam-wrap');
    const overlay = document.getElementById('overlay');
    const hudLabel = document.getElementById('hudLabel');
    const hudConf = document.getElementById('hudConf');
    const numEl = document.getElementById('futuristicNumber');

    // Launch flow
    const startBtn = document.getElementById('startBtn');
    const gate = document.getElementById('gate');
    startBtn.addEventListener('click', async () => {
      try{
        await openFullscreen();
      }catch(e){ /* ignore if rejected */ }
      await init();
      gate.style.display='none';
    }, {passive:true});

    async function openFullscreen(){
      const el = document.documentElement;
      if (el.requestFullscreen) return el.requestFullscreen();
      if (el.webkitRequestFullscreen) return el.webkitRequestFullscreen();
      return Promise.resolve();
    }

    // Load the model and setup the webcam
    async function init() {
      const modelURL = URL + "model.json";
      const metadataURL = URL + "metadata.json";

      model = await tmImage.load(modelURL, metadataURL);
      maxPredictions = model.getTotalClasses();

      // Setup webcam (use back camera if available)
      const flip = true; // mirror for selfie-like UX; set to false if you prefer raw
      const vw = Math.min(1080, window.innerWidth);
      const vh = Math.min(1440, window.innerHeight);
      webcam = new tmImage.Webcam(vw, vh, flip);

      // On iOS/Safari mobile, must be called in a user gesture (handled by Start button)
      await webcam.setup({ facingMode: { ideal: 'environment' } });
      await webcam.play();
      requestAnimationFrame(loop);

      // Inject canvas
      wrap.prepend(webcam.canvas);

      // Prepare label container in memory (not visible, but we keep parity)
      labelContainer = document.createElement('div');
      for (let i = 0; i < maxPredictions; i++) labelContainer.appendChild(document.createElement('div'));

      // Resize to fit full screen
      onresize();
      window.addEventListener('resize', onresize);
    }

    function onresize(){
      // Make canvas fully cover viewport
      const c = webcam.canvas;
      if(!c) return;
      c.style.width = '100%';
      c.style.height = '100%';
    }

    async function loop() {
      webcam.update();
      await predict();
      requestAnimationFrame(loop);
    }

    // Map classes to futuristic numbers 1–5. If there are fewer than 5 classes, we map sequentially.
    function classIndexToNumber(idx){
      return (idx % 5) + 1; // cycles 1..5
    }

    // Run predictions and update HUD / hologram
    async function predict() {
      const pred = await model.predict(webcam.canvas);

      // Find top prediction
      let topIdx = 0; let top = pred[0];
      for (let i=1;i<pred.length;i++){ if (pred[i].probability > top.probability){ top = pred[i]; topIdx = i; } }

      const conf = top.probability;
      hudLabel.textContent = `${top.className}`;
      hudConf.textContent = `${Math.round(conf*100)}%`;

      // Update debug (optional, kept hidden in DOM)
      for (let i = 0; i < pred.length; i++) {
        labelContainer.childNodes[i].innerHTML = `${pred[i].className}: ${pred[i].probability.toFixed(2)}`;
      }

      // Threshold: show neon number + activate overlay when >= 0.5
      if (conf >= 0.5){
        const num = classIndexToNumber(topIdx);
        if (numEl.textContent !== String(num)){
          // Restart animation by toggling class
          numEl.classList.remove('active');
          // force reflow
          void numEl.offsetWidth;
          numEl.textContent = String(num);
          numEl.classList.add('active');
        } else if (!numEl.classList.contains('active')){
          numEl.classList.add('active');
        }
        overlay.classList.add('active');
      } else {
        numEl.classList.remove('active');
        overlay.classList.remove('active');
      }
    }

    // iOS wake lock-ish behavior workaround to keep camera flowing
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && webcam && webcam.stream){ webcam.play(); }
    });
  </script>
</body>
</html>
