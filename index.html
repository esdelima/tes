<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Live Scan - Teachable Machine (Rear Camera, Fullscreen)</title>
  <style>
    :root{height:100%}
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #app{display:flex;flex-direction:column;height:100%}

    /* video fills screen and keeps aspect cover */
    #camera-wrap{position:relative;flex:1;display:flex;align-items:center;justify-content:center;overflow:hidden}
    video#video{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);min-width:100%;min-height:100%;width:auto;height:auto;object-fit:cover}

    /* canvas used for prediction is visually hidden but matches video size */
    canvas#capture{display:none}

    /* overlays */
    #controls{position:fixed;left:12px;bottom:12px;display:flex;gap:8px;z-index:40}
    button{background:rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.12);color:#fff;padding:10px 12px;border-radius:10px;font-size:16px}

    #labels{position:fixed;right:12px;bottom:12px;max-width:46%;backdrop-filter:blur(6px);background:linear-gradient(180deg,rgba(0,0,0,0.35),rgba(0,0,0,0.6));padding:10px;border-radius:10px;z-index:40}
    .label-line{font-size:16px;line-height:1.2;margin:4px 0}
    .prob{opacity:0.85;font-weight:600}

    /* small heads-up text at top */
    #topbar{position:fixed;left:50%;transform:translateX(-50%);top:8px;background:rgba(0,0,0,0.35);padding:6px 10px;border-radius:999px;font-size:13px}

    @media (orientation:portrait){#labels{max-width:86%}}
  </style>
</head>
<body>
  <div id="app">
    <div id="camera-wrap">
      <video id="video" playsinline autoplay muted></video>
      <canvas id="capture"></canvas>
    </div>

    <div id="topbar">Live Scan — Kamera Belakang • Fullscreen</div>

    <div id="controls">
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <button id="torchBtn" disabled>Toggle Torch</button>
      <button id="fsBtn">Fullscreen</button>
    </div>

    <div id="labels" aria-live="polite"></div>
  </div>

  <!-- TensorFlow / Teachable Machine libs -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>

  <script>
    // Use the model URL provided by the user
    const MODEL_BASE = 'https://teachablemachine.withgoogle.com/models/OEXYCpyXs/';

    let model = null;
    let maxPredictions = 0;
    let video = document.getElementById('video');
    let canvas = document.getElementById('capture');
    let labelsEl = document.getElementById('labels');
    let startBtn = document.getElementById('startBtn');
    let stopBtn = document.getElementById('stopBtn');
    let torchBtn = document.getElementById('torchBtn');
    let fsBtn = document.getElementById('fsBtn');

    let stream = null;
    let track = null;
    let imageCapture = null;
    let running = false;
    let rafId = null;

    async function loadModel(){
      const modelURL = MODEL_BASE + 'model.json';
      const metadataURL = MODEL_BASE + 'metadata.json';
      model = await tmImage.load(modelURL, metadataURL);
      maxPredictions = model.getTotalClasses();
    }

    async function startCamera(){
      // Prefer rear camera. Some browsers require facingMode: { exact: 'environment' } but it can throw
      const constraintsList = [
        {video: {width: {ideal:1280}, height: {ideal:720}, facingMode: {exact: 'environment'}}},
        {video: {width: {ideal:1280}, height: {ideal:720}, facingMode: 'environment'}},
        {video: {width: {ideal:640}, height: {ideal:480}}}
      ];

      for (const c of constraintsList){
        try{
          stream = await navigator.mediaDevices.getUserMedia(c);
          break;
        }catch(e){
          // try next
        }
      }

      if(!stream) throw new Error('Tidak dapat mengakses kamera. Pastikan situs dijalankan via HTTPS dan akses kamera diizinkan.');

      video.srcObject = stream;

      // get track for torch control
      track = stream.getVideoTracks()[0];

      // try create ImageCapture for torch capabilities
      try{
        imageCapture = new ImageCapture(track);
      }catch(e){
        imageCapture = null;
      }

      await video.play();

      // size canvas to video presentation size
      canvas.width = video.videoWidth || video.clientWidth;
      canvas.height = video.videoHeight || video.clientHeight;
    }

    async function enableTorchIfAvailable(){
      if(!track) return false;
      const cap = track.getCapabilities ? track.getCapabilities() : {};
      if(cap.torch){
        torchBtn.disabled = false;
        return true;
      }
      // some implementations expose torch via advanced constraints - try detect via photo capabilities
      try{
        const pc = imageCapture ? await imageCapture.getPhotoCapabilities() : null;
        if(pc && pc.fillLightMode && pc.fillLightMode.length){
          // not guaranteed; enable toggle and try
          torchBtn.disabled = false;
          return true;
        }
      }catch(e){}
      torchBtn.disabled = true;
      return false;
    }

    async function setTorch(on){
      if(!track) return;
      const cap = track.getCapabilities ? track.getCapabilities() : {};
      if(cap.torch){
        try{
          await track.applyConstraints({advanced:[{torch:on}]});
          return;
        }catch(e){/* fallback below */}
      }
      // fallback: try ImageCapture.takePhoto with fillLightMode if available (nonstandard)
      if(imageCapture){
        try{
          await imageCapture.takePhoto({fillLightMode: on ? 'flash' : 'off'});
        }catch(e){/* ignore */}
      }
    }

    async function startLoop(){
      running = true;
      const ctx = canvas.getContext('2d');
      async function loop(){
        if(!running) return;
        // draw current video frame to canvas sized to video resolution
        canvas.width = video.videoWidth || video.clientWidth;
        canvas.height = video.videoHeight || video.clientHeight;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        // predict using the tmImage model. Pass the canvas element
        if(model){
          try{
            const prediction = await model.predict(canvas);
            // sort by probability desc
            prediction.sort((a,b)=>b.probability - a.probability);
            // show top 3
            labelsEl.innerHTML = '';
            for(let i=0;i<Math.min(3,prediction.length);i++){
              const p = prediction[i];
              const el = document.createElement('div');
              el.className = 'label-line';
              el.innerHTML = `<span class="prob">${(p.probability*100).toFixed(1)}%</span> — ${p.className}`;
              labelsEl.appendChild(el);
            }
          }catch(e){
            console.warn('Prediction error', e);
          }
        }

        rafId = requestAnimationFrame(loop);
      }
      loop();
    }

    async function stopAll(){
      running = false;
      if(rafId) cancelAnimationFrame(rafId);
      if(stream){
        stream.getTracks().forEach(t=>t.stop());
      }
      stream = null;
      track = null;
      imageCapture = null;
      video.srcObject = null;
      labelsEl.innerHTML = '';
      stopBtn.disabled = true;
      startBtn.disabled = false;
      torchBtn.disabled = true;
    }

    // UI wiring
    startBtn.addEventListener('click', async ()=>{
      startBtn.disabled = true;
      try{
        startBtn.textContent = 'Loading model...';
        if(!model) await loadModel();
        startBtn.textContent = 'Starting camera...';
        await startCamera();
        await enableTorchIfAvailable();

        // attempt to enter fullscreen on user gesture
        try{ await document.documentElement.requestFullscreen(); }catch(e){}

        startBtn.textContent = 'Running';
        stopBtn.disabled = false;
        startLoop();
      }catch(err){
        console.error(err);
        alert(err.message || err);
        startBtn.disabled = false;
        startBtn.textContent = 'Start';
      }
    });

    stopBtn.addEventListener('click', async ()=>{
      await stopAll();
      try{ if(document.fullscreenElement) await document.exitFullscreen(); }catch(e){}
    });

    torchBtn.addEventListener('click', async ()=>{
      if(!track) return;
      // naive toggle: read from attribute
      const on = torchBtn.dataset.on !== 'true';
      await setTorch(on);
      torchBtn.dataset.on = on ? 'true' : 'false';
      torchBtn.textContent = on ? 'Torch: ON' : 'Toggle Torch';
    });

    fsBtn.addEventListener('click', async ()=>{
      try{
        if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
        else await document.exitFullscreen();
      }catch(e){console.warn(e)}
    });

    // clean up when page is hidden / unloaded
    document.addEventListener('visibilitychange', ()=>{
      if(document.visibilityState === 'hidden'){
        // pause predictions but do not stop camera (keeps session); to fully stop uncomment stopAll()
        running = false;
      }else{
        if(stream && !running) startLoop();
      }
    });

    window.addEventListener('beforeunload', ()=>{ if(stream) stopAll(); });
  </script>
</body>
</html>
