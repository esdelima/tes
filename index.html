<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>AR Poster Placer — Poster 4:5 (No Marker)</title>
  <style>
    html,body{height:100%;margin:0;font-family:Inter, Roboto, system-ui, Arial}
    #container{position:fixed;inset:0;background:#000}
    #ar-button{position:fixed;left:50%;transform:translateX(-50%);bottom:20px;padding:12px 18px;border-radius:10px;background:#0066ff;color:#fff;border:none;font-weight:600;box-shadow:0 8px 24px rgba(0,0,0,0.3);}
    #hint{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:8px;font-size:14px}
    #preview{position:fixed;right:12px;top:12px;background:#fff;padding:12px;border-radius:10px;max-width:320px;box-shadow:0 8px 20px rgba(0,0,0,0.12);color:#111}
    canvas#posterCanvas{display:none}
    #exitBtn{position:fixed;right:12px;bottom:20px;padding:8px 12px;border-radius:8px;background:#fff;border:none}
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="hint">AR tanpa marker — ketuk layar untuk menempatkan poster 4:5.</div>
  <div id="preview">
    <h4 style="margin:0 0 8px 0">Preview Poster (4:5)</h4>
    <img id="previewImg" alt="poster preview" style="width:160px;height:200px;object-fit:cover;border-radius:6px;border:1px solid #eee;" />
    <p style="margin:8px 0 0 0;font-size:13px;color:#444">Poster menampilkan 5 informasi futuristik. Ketuk <strong>Enter AR</strong> untuk menempatkannya di dunia nyata.</p>
  </div>
  <button id="ar-button">Enter AR</button>
  <button id="exitBtn" style="display:none">Exit AR</button>

  <!-- hidden canvas used to create poster texture -->
  <canvas id="posterCanvas" width="800" height="1000"></canvas>

  <!-- Three.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    // --- Content for the poster (5 informasi futuristik) ---
    const infos = [
      {title: 'Kota Terapung', body: 'Kota modular terapung dengan pertanian vertikal & energi terbarukan.'},
      {title: 'Transportasi Holografik', body: 'Rute holografis untuk navigasi pejalan kaki & drone.'},
      {title: 'Antarmuka Otak-Komputer', body: 'Interaksi non-invasif untuk kontrol perangkat & input teks.'},
      {title: 'Energi Fusi Mini', body: 'Generator fusi skala kecil memberi listrik bersih tanpa emisi.'},
      {title: 'AI Kesehatan Pribadi', body: 'AI yang memantau biometrik real-time & pencegahan proaktif.'}
    ];

    // Draw poster to canvas (aspect ratio 4:5 => 800x1000)
    function drawPoster(){
      const c = document.getElementById('posterCanvas');
      const ctx = c.getContext('2d');
      // background
      ctx.fillStyle = '#0f1724';
      ctx.fillRect(0,0,c.width,c.height);
      // header
      ctx.fillStyle = '#00d1ff';
      ctx.fillRect(0,0,c.width,120);
      ctx.fillStyle = '#021024';
      ctx.font = 'bold 44px sans-serif';
      ctx.fillText('5 Informasi Futuristik', 24, 78);

      // draw each info block
      const margin = 24;
      const blockW = c.width - margin*2;
      const blockH = (c.height - 160 - margin*4) / 5; // space for 5 blocks
      ctx.font = 'bold 26px sans-serif';
      ctx.textBaseline = 'top';
      for (let i=0;i<infos.length;i++){
        const x = margin;
        const y = 140 + margin + i*(blockH + margin);
        // block bg
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.fillRect(x,y,blockW,blockH);
        // accent bar
        ctx.fillStyle = ['#ff7a18','#7b61ff','#00d1ff','#14b8a6','#f97316'][i%5];
        ctx.fillRect(x, y, 8, blockH);
        // title
        ctx.fillStyle = '#fff';
        ctx.font = '600 22px sans-serif';
        ctx.fillText((i+1)+'. '+infos[i].title, x+16, y+10);
        // body (wrap)
        ctx.fillStyle = '#e6eef8';
        ctx.font = '16px sans-serif';
        wrapText(ctx, infos[i].body, x+16, y+40, blockW-32, 20);
      }
    }

    function wrapText(ctx, text, x, y, maxWidth, lineHeight){
      const words = text.split(' ');
      let line = '';
      for (let n=0;n<words.length;n++){
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && n>0){
          ctx.fillText(line, x, y);
          line = words[n] + ' ';
          y += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, y);
    }

    drawPoster();
    // set preview image
    document.getElementById('previewImg').src = document.getElementById('posterCanvas').toDataURL();

    // --- WebXR / Three.js AR placement ---
    let renderer, scene, camera, xrSession, referenceSpace, hitTestSource, reticle;

    const container = document.getElementById('container');
    const arButton = document.getElementById('ar-button');
    const exitBtn = document.getElementById('exitBtn');

    function initThree(){
      renderer = new THREE.WebGLRenderer({alpha:true, antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.xr.setReferenceSpaceType('local');
      container.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera();

      // light
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      scene.add(light);

      // reticle to show hit test
      const geometry = new THREE.RingGeometry(0.07, 0.09, 32).rotateX(-Math.PI/2);
      const material = new THREE.MeshBasicMaterial({color:0xffffff});
      reticle = new THREE.Mesh(geometry, material);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      window.addEventListener('resize', ()=>{
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function makePosterMesh(){
      const canvas = document.getElementById('posterCanvas');
      const tex = new THREE.CanvasTexture(canvas);
      tex.encoding = THREE.sRGBEncoding;
      const aspect = canvas.width / canvas.height; // 0.8 (4:5)
      const width = 0.6; // meters
      const height = width / aspect; // maintain 4:5
      const geometry = new THREE.PlaneGeometry(width, height);
      const material = new THREE.MeshBasicMaterial({map:tex, side:THREE.DoubleSide, transparent:false});
      const mesh = new THREE.Mesh(geometry, material);
      // add thin frame
      const frameMat = new THREE.MeshBasicMaterial({color:0x021024});
      return mesh;
    }

    async function startXR(){
      if (!navigator.xr) { alert('WebXR tidak tersedia pada perangkat ini.'); return; }
      try{
        xrSession = await navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['hit-test','local-floor'] });
      }catch(e){ alert('Gagal memulai sesi AR: '+e.message); return; }

      initThree();
      renderer.xr.setSession(xrSession);

      referenceSpace = await xrSession.requestReferenceSpace('local');

      const viewerSpace = await xrSession.requestReferenceSpace('viewer');
      hitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

      // set DOM overlay so buttons visible? Not all platforms support dom-overlay; we skip to keep simple

      xrSession.addEventListener('end', onSessionEnded);

      // handle select (tap) to place poster
      xrSession.addEventListener('select', (ev)=>{
        if (reticle.visible){
          const poster = makePosterMesh();
          poster.position.setFromMatrixPosition(reticle.matrix);
          // rotate to face camera (align with camera's y rotation)
          const camPose = renderer.xr.getCamera(camera);
          const camDir = new THREE.Vector3();
          camPose.getWorldDirection(camDir);
          const yaw = Math.atan2(camDir.x, camDir.z);
          poster.rotation.set(0, yaw + Math.PI, 0);
          scene.add(poster);
        }
      });

      // enable an input source to receive select events (some devices require a transient input)
      xrSession.addEventListener('inputsourceschange', ()=>{});

      // render loop
      const onXRFrame = (time, frame) => {
        xrSession.requestAnimationFrame(onXRFrame);
        const session = frame.session;
        const pose = frame.getViewerPose(referenceSpace);
        if (pose){
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length > 0){
            const hit = hitTestResults[0];
            const hitPose = hit.getPose(referenceSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(hitPose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
        renderer.render(scene, camera);
      };

      xrSession.requestAnimationFrame(onXRFrame);

      arButton.style.display = 'none';
      exitBtn.style.display = 'block';
    }

    function onSessionEnded(){
      if (renderer && renderer.domElement){
        container.removeChild(renderer.domElement);
      }
      if (xrSession){ xrSession = null; }
      arButton.style.display = 'block';
      exitBtn.style.display = 'none';
    }

    arButton.addEventListener('click', async ()=>{
      await startXR();
    });

    exitBtn.addEventListener('click', ()=>{
      if (xrSession) xrSession.end();
    });

    // Basic feature-detection: hide AR button if WebXR not available
    (async function checkXR(){
      if (navigator.xr && navigator.xr.isSessionSupported){
        try{
          const supported = await navigator.xr.isSessionSupported('immersive-ar');
          if (!supported){ document.getElementById('hint').textContent = 'AR tidak didukung di perangkat ini. Preview tersedia.'; arButton.disabled=true; }
        }catch(e){ console.warn(e); }
      } else {
        document.getElementById('hint').textContent = 'WebXR tidak tersedia. Gunakan perangkat mobile modern (Chrome/Edge) untuk AR.';
        arButton.disabled = true;
      }
    })();

    // polyfill note: some Android devices need WebXR enabled; this code assumes a proper WebXR-capable browser.

  </script>
</body>
</html>
